# Modelos Lineales Mixtos (LMM)

Esta técnica es la más potente para analizar datos longitudinales ya que permite introducir efectos aleatorios y especificar la estructura de correlaciones de los residuos dentro de un mismo individuo.

Además, a diferencia de las dos técnicas anteriores, permite trabajar con missings.


## Ecuación

$$
y_{ij} = \beta_{0i} + \sum_{k=1}^K \beta_{ki} x_{ijk} + e_{ij}
$$

Donde $i$ representa al individuo, $j$ representa el momento (de uno hasta hasta el número de observaciones del individuo $i$),

- $x_{ijk}$ valor de la $k$-ésima variable independiente del individuo $i$ en el momento $j$.

- $\beta_{0i} \sim N\left(\beta_0, \sigma_{\beta_0}^2\right)$ es la constante del modelo aunque en general se supone aleatoria, o sea que tiene cierta varianza entre individuos y está centrada en la contaste $\mu$.

- $\beta_{ki} \sim N\left(\beta_k, \sigma_{\beta_k}^2\right)$: pendientes o coeficientes de las variables del modelo. Pueden ser aleatorias, o sea, variar entre individuos.

En general puede haber correlación entre la contante $\beta_{0i}$ y las pendientes $\beta_{ki}$. 

El vector formado por la constante y por los coeficientes aleatorios, son los **efectos aleatorios** y se supone que sigue una distribución normal multivariada: 

$$\vec{\beta}_i = (\beta_{0i},\beta_{1i},\ldots,\beta_{Ki})^t \sim N\left(\vec{\beta}, \Omega) \right)$$

- El vector formado por los errores de un individuo $\vec{e_i} \sim N(\vec{0},\Sigma_i)$, sigue una distribuión normal multivariante con una cierta matriz de covarianzas $\Sigma_i$ que no tiene porqué ser la misma ni del mismo tamaño para todos los individuos ya que no todos los individuos tendrán el mismo número de observaciones. **Los errores son independientes de la constante aleatoria y de los coeficientes aleatorios**.



**Observaciones**

- Para ajustar este modelo los datos se disponen de forma vertical.

- El modelo LMM es muy flexible y potente. No sólo permite especificar efectos aleatorios con lo que evaluar la variabilidad de ciertos efectos o variables entre individuos sinó también la correlación residual entre las distintas medidas repetidas en un mismo individuo.

- Cuando hay missings en una observación no hace falta eliminar las otras del mismo individuo, ya que cada fila aquí es una observación y no un individuo. 

- La esperanza de la constante y coeficientes aleatorios $\vec{\beta}_i$ es la misma para todos los individuos, $\vec{\beta}$, y la matriz de covarianzas, $\Omega$,  también (**homocedesticidad**).

- Si un coeficiente no es aleatorio, se puede notar como $\beta_{k'i} = \beta_{k'}$ en lugar de suponer que sigue una distribución normal. También se podría pensar que sigue una distribución "normal" con varianza cero. 

- Los **efectos fijos** son la esperanza de los efectos aleatorios ($\beta_0, \beta_1, \ldots, \ldots, \beta_k$). Además, cuando un coeficiente no es aleatorio (tiene varianza cero) se denomina fijo directamente. 

- Hay un número limitado de efectos aleatorios que se pueden incorporar en el modelo, que no puede exceder el número de medidas por individuo.

- La presencia de **efectos aleatorios inducen correlación** entre medidas de un mismo individuo. Sin embargo, según que estructura de correlación sólo se puede conseguir definiendo también una estructura de correlación entre residuos no nula (no diagonal).

    - Considerando los coeficientes del tiempo como aleatorios se induce correlación distinta según los tiempos que se toman las medidas.
    
    - Considerando el coeficiente de una variable **no** cambiante en el tiempo se induce **heterocedesticidad** (varianza diferente) entre los individuos.
    
Por ejemplo, supongamos un modelo con efecto lineal del tiempo y una covariable no cambiante del tiempo ($x_i$). Y tomamos la constante y el coeficiente de $x_i$ aleatorios y ambos no correlacionados.
    
$$y_{ij} = \beta_{0i} + \beta_1 t_{ij} + \beta_{2i} x_i$$
    
Luego la varianza de $y_{ij}$ es $\sigma_{\beta_{0}}^2 + \sigma_{2i}^2 x_i^2$. Si $x_i$ vale 0 para el grupo placebo y 1 para los tratados, entonces la varianza del grupo placebo será $\sigma_{\beta_{0}}^2$ y para los tratados $\sigma_{\beta_{0}}^2 + \sigma_{\beta_{2}}^2$ 
    

- A diferencia de las técnicas de sumas de cuadrados y de respuesta multivariante, en que la variable **tiempo** se trata como a un **factor**, con los LMM se tratar también como **variable continua**. 



## Casos particulares

### Modelo con constante aleatoria

$$y_{ij} = \beta_{0i} + \beta_{1} t_{ij} + e_{ij}$$

Donde $\beta_{0i} \sim N(\beta_0, \sigma_{\beta_0})$, y $\beta_1$ es el coeficiente fijo del tiempo. En este caso se supone que el tiempo tiene un efecto lineal. 




```{r, echo=FALSE}
set.seed(123456)
a <- 12
p <- 5
n <- a*p
sigmaA <- 0.5
sigmaE <- 0.1
mu <- rnorm(a, 0, sigmaA)
ind <- rep(1:a, each=p)
tiempo <- rep(1:p, a)
beta <- 2
error <- rnorm(n,0,sigmaE)
resp <- mu[ind]+beta*tiempo+error
library(ggplot2)
dd <- data.frame(resp,tiempo,ind)
p <- ggplot(data = dd, aes(x = tiempo, y = resp, group = ind))
p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
```



Podríamos añadir un término cuadrático, cúbico, etc. si el efecto no fuera lineal y añadiéramos un término cuadrático:

$$y_{ij} = \beta_{0i} + \beta_{1} t_{ij} + \beta_{2} t_{ij}^2 + e_{ij}$$
en este caso, $x_{ij1}=t_{ij}$ y $x_{ij2}=t_{ij}^2$.

```{r, echo=FALSE}
set.seed(123456)
a <- 12
p <- 5
n <- a*p
sigmaA <- 2
sigmaE <- 1
mu <- rnorm(a, 0, sigmaA)
ind <- rep(1:a, each=p)
tiempo <- rep(1:p, a)
beta1 <- 1
beta2 <- 3
error <- rnorm(n,0,sigmaE)
resp <- mu[ind]+beta1*tiempo+beta2*tiempo^2+error
library(ggplot2)
dd <- data.frame(resp,tiempo,ind)
p <- ggplot(data = dd, aes(x = tiempo, y = resp, group = ind))
p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
```

**Correlacion entre observaciones**

Si los errores son independientes, las observaciones de la variable respuesta de un mismo individuo están correlacionadas. Y esta correlación es constante: no depende de la distancia entre las medidas.

$$\text{corr}(y_{i1},y_{i2}) = \text{corr}(y_{i1},y_{i3}) = \ldots = \frac{\sigma_{\beta_{0}}^2}{\sigma_{e}^2}$$

A esta correlación también se la conoce como **coeficiente de correlación intraclase (ICC)**


#### Modelo con pendiente y constante aleatoria

$$y_{ij} = \beta_{0i} + \beta_{1i} t_{ij} + e_{ij}$$

$\vec{\beta}_i = (\beta_{0i}, \beta_{1i})^t \sim N\left((\beta_0,\beta_1)^t, \Omega\right)$, donde


$$\Omega= 
\begin{pmatrix}
\sigma_{\beta_0}^2 & \sigma_{\beta_0,\beta_1} \\
\sigma_{\beta_0,\beta_1} & \sigma_{\beta_1}^2
\end{pmatrix}
$$


El término $\sigma_{\beta_0,\beta_1}$ es la covarianza entre la constante y la pendiente. Ésta en general puede no ser cero.


```{r, echo=FALSE}
set.seed(123456)
a <- 12
p <- 3
n <- a*p
sigmaA <- 0.5
sigmaB <- 0.3
covAB <-  -0.15
sigmaE <- 0.1
mubeta <- MASS::mvrnorm(a, c(20,-1), rbind(c(sigmaA^2,covAB),c(covAB,sigmaB^2)))
mu <- mubeta[,1]
beta <- mubeta[,2]
ind <- rep(1:a, each=p)
tiempo <- rep(1:p, a)
error <- rnorm(n,0,sigmaE)
resp <- mu[ind]+beta[ind]*tiempo+error
library(ggplot2)
dd <- data.frame(resp,tiempo,ind)
p <- ggplot(data = dd, aes(x = tiempo, y = resp, group = ind))
p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
```


En este gráfico se observa primero que las pendientes son diferentes entre los individuos. Y además, que los individuos que empiezan de más arriba bajan más rápido y viceversa. Así pues, la correlación entre la constante y la pendiente es negativa.

**Correlacion entre observaciones**

En el modelo con constante y pendientes aleatorios, si asumimos que los errores son independientes, las observaciones de la variable respuesta de un mismo individuo están correlacionadas. Y esta correlación depende de los momentos:

$$\text{corr}(y_{i1},y_{i2}) = \frac{\sigma_{\beta_{0}}^2+\sigma_{\beta_{1i}^2 \cdot t_1 \cdot t_2}}{\sqrt{\sigma_{\beta_{0}}^2+\sigma_{\beta_{1}}^2 \cdot t_1^2 + \sigma_e^2}\sqrt{\sigma_{\beta_{0}}^2+\sigma_{\beta_{1}}^2 \cdot t_2^2 + \sigma_e^2}}$$

Por lo tanto depende tanto de $t_1$ como de $t_2$ y no sólo de la distancia entre las medidas.

Si lo comparamos con el AR(1):

Ejemplo con $t_1=1$, $\sigma_{\beta_{0}}^2=0.5^2$, $\sigma_{\beta_{1}}^2=0.3^2$ y $\sigma_{e}^2=0.1^2$, con $t_1=1$

```{r, echo=FALSE}
t1 <- 1
s0 <- 0.5^2
s1 <- 0.3^2
s <- 0.1^2

ff <- function(t2) (s0+s1*t1*t2)/(sqrt(s0+s1*t1^2+s)*sqrt(s0+s1*t2^2+s))

curve(ff, t1, t1+10, col="blue", xlab=expression(t[2]), ylab="Correlación",ylim=c(0,1))
curve(ff(2)^x, t1, t1+10, add=TRUE, col="green")
legend("topright", c("random","AR"), col=c("blue","green"), bty="n", lty=1)
```

En este ejemplo, vemos como especificando el AR y la pendiente fija, la correlación entre observaciones baja más rápidamente a medida que las observaciones se alejan ($t_2$) que lo que se consigue especificando la pendiente aleatoria y los errores incorrelacionados.

## Simplificación del modelo

Empezaremos con el modelo más general, o sea, sin asumir independencia de los residuos, con efectos aleatorios (todos los que se admitan) correlacionados.

En cuanto a los efectos fijos, se incluyrán también los máximos que se puedan, interacciones si es pertinente,  terminos cuadráticos (cúbicos), ...

A partir de aquí se simplificará el modelo en el siguiente orden:

### Significación de los efectos aleatorios

La hipótesis nula para contrastar los factores de efectos aleatorios es que su varianza es igual a cero. Por ejemplo para la constante aleatoria:

$$\left\{\begin{array}{l}
\text{H}_0: \sigma_{\beta_0}^2 = 0 \\
\text{H}_1: \sigma_{\beta_0}^2 > 0
\end{array}\right.
$$

Hay diferentes técnicas estadísticas para contrastar estos tests, pero no son estándard. El problema es que la varianza de una distribución normal no puede ser cero, por lo tanto la hipótesis nula está fuera del espacio parametrico ("beyond boundary"). Existen, pero, algunas herramientas en R que lo realizan mediante técnicas de remuestreo ("bootstrap"). Éstas son complejas desde el punto de visto teórico y no se explicarán en este curso (véase el paquete de R `pbkrtest` @pbkrtest2014).
Otra alternativa es usar índices como el AIC o BIC (cuanto más bajo mejor), que proporciona la función `anova` en la comparación de dos modelos: uno considerando el coeficiente como aleatorio ($\beta_{ik}$) el otro considerando el coeficiente como fijo ($\beta_{k}$).


### Elección matriz covarianzas de los efectos aleatorios

Si en el paso anterior, hay más de un efecto aleatorio significativo, seguidamente hay que contrastar si la correlación entre ellos es cero o no. Es decir, H$_0$ postula que la matriz $\Omega$ es diagonal, mientras que la H$_1$ se asume que las correlaciones pueden ser no nulas.

$$\left\{\begin{array}{l}
\text{H}_0: \Omega= 
\begin{pmatrix}
\sigma_{\beta_0}^2 & 0 \\
0 & \sigma_{\beta_1}^2
\end{pmatrix}\\
\text{H}_1: \Omega= 
\begin{pmatrix}
\sigma_{\beta_0}^2 & \sigma_{\beta_0\beta_1} \\
\sigma_{\beta_0\beta_1} & \sigma_{\beta_1}^2
\end{pmatrix}
\end{array}\right.
$$

Como la matriz diagonal es un caso particular de la matriz general, en que las correlaciones son cero se puede aplicar el test de razón de verosimilitudes.



### Estructura de correlación de los errores

Mediante el **test de razón de verosimilitudes (LRT)**, se comparan las verosimilitudes de dos modelos.

Hay que ajustar el modelo mediante el criterio de máxima verosimilutud.

**Los modelos tienen que estar anidados**: la matriz de covarianzas de los errores de un modelo se pueda expresar como un caso particular de la del otro modelo. Por ejemplo, la matriz sin estructura sería la más general de todas, y la matriz de simetría compuesta sería un caso particular en que todas las correlación son iguales.
No están anidadas las matrices con estructura MA(1) y una AR(1).

La simetría compuesta es un caso particular de matriz sin estructura.


$$
\begin{pmatrix}
1 &  \rho_{12} & \rho_{13} \\
\rho_{12} & 1 & \rho_{23} \\
\rho_{13} & \rho_{23} & 1 \\
\end{pmatrix}
\Rightarrow \color{blue}{(\rho_{12}=\rho_{13}=\rho_{23} =\rho)} \Rightarrow
\begin{pmatrix}
1 &  \rho & \rho \\
\rho & 1 & \rho \\
\rho & \rho & 1 \\
\end{pmatrix}
$$


La matriz que supone independencia entre los residuos es un caso particular de matriz de simetría compuesta.

$$
\begin{pmatrix}
1 &  \rho & \rho \\
\rho & 1 & \rho \\
\rho & \rho & 1 \\
\end{pmatrix}
\Rightarrow \color{blue}{(\rho=0)} \Rightarrow
\begin{pmatrix}
1 &  0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{pmatrix}
$$


Pero no se puede pasar de una AR(1) a una MA(1) ni viceversa. En este caso el test LRT no es válido pero sí el criterio AIC o BIC.

$$
\begin{pmatrix}
1 &  \rho & \rho^2 \\
\rho & 1 & \rho \\
\rho^2 & \rho & 1 \\
\end{pmatrix}
\Rightarrow \color{blue}{(????)} \Rightarrow
\begin{pmatrix}
1 & \frac{\theta}{1+\theta^2} & 0 \\
\frac{\theta}{1+\theta^2} & 1 & \frac{\theta}{1+\theta^2} \\
0 & \frac{\theta}{1+\theta^2} & 1 \\
\end{pmatrix}
$$

Una matriz AR(p') está anidada a AR(p) si p' < p, o sea un AR de orden menor está anidado a una de orden mayor, y por lo tanto, se puede aplicar un LRT para decidir el valor de p. Por ejemplo, un AR de orden 3 se especificaría como `correlation = corARMA(p=3, q=0)`. Lo mismo sucede para decidir el orden de una MA. Por ejemplo, para una MA de orden 4, `correlation = corARMA(p=0, q=4)`.


**Heterocedesticidad**:

La heterocedesticidad se produce cuando los parámetros de la matriz de covarianzas $\Sigma$ dependen de variables. Por ejemplo, del sexo o de la edad, etc, o de una combinación lineal de las variables (valor esperado).

Por ejemplo, que la varianza sea distinta según el sexo, mientras que la correlación sea la misma:

para hombres

$$ 
\Sigma_{\text{H}} = \sigma_{\text{H}}^2
\begin{pmatrix}
1 &  \rho & \rho^2 \\
\rho & 1 & \rho \\
\rho^2 & \rho & 1 \\
\end{pmatrix}
$$, 

y para las mujeres

$$ 
\Sigma_{\text{M}} = \sigma_{\text{M}}^2
\begin{pmatrix}
1 &  \rho & \rho^2 \\
\rho & 1 & \rho \\
\rho^2 & \rho & 1 \\
\end{pmatrix}
$$

También podríamos definir las varianzas (diagonal de $\Sigma$), en función del tiempo.

Veremos como es posible modelizar diferentes varianzas distintas entre grupos de individuos con la función `lme` de R que se describirá en esta sección. 


### Efectos fijos

Una vez escogida la estructura de covarianzas de los efectos aleatorios, de los errores, y qué efectos son aleatorios (contraste sobre sus varianzas), vamos a contrastar la significación de los efectos fijos:

Para ello, se puede usar el test de Wald para testar un único parámetro:

$$
\left\{\begin{array}{l}
\text{H}_0: \beta_1 = 0\\
\text{H}_1: \beta_1 \neq 0
\end{array}\right.
$$

o LRT para testar más de un parámetro a la vez, por ejemplo las dummies de un factor de más de dos categorías:

$$
\left\{\begin{array}{l}
\text{H}_0: \beta_1 = \beta_2 = 0\\
\text{H}_1: \text{alguno diferente de 0}
\end{array}\right.
$$

## Validación del modelo

Una vez simplificado y seleccionado el modelo, hay que validarlo.

De todas las premisas a comprobar en este curso nos limitaremos a las asumciones sobre los **residuos**.

Para ellos se realizarán dos gráficos: 

- **Residuos estandarizados vs valores predichos:** en este gráficos debería aparecer una nube de puntos 
uniformemente distribuida sin ninguna tendencia. Ésto nos indicaría que no nos hemos dejado ninguna variable, o ningún término cuadrático o cúbico del tiempo.

- **QQ-plot:** éste gráfico está pensado para comprobar la normalidad. Si los puntos se encuentran alrededor de la diagonal sin seguir ningún patrón, dará evidencia de que los residuos siguen una distribución normal


Hay otras premisas que se deberían comprobar, como por ejemplo la normalidad de los efectos aleatorios. Pero, por su complejidad, no se verá en este curso.


La valicación de los **efectos aleatorios** es más compleja. Una posibilidad "naive" es considerar que sus estimaciones siguen una distribución normal y que su distribución no depende de ninguna covariable a nivel de individuo. Veremos como las funciones de R para estimar los LMM proporcionan las estimaciones de los efectos aleatorios ("Empirical Bayes Estimates"). Aunque los efectos aleatorios se suponen normalmente distribuidos, los "Empirical Bayes Estimates" no tienen porqué.

## Predicciones

### Efectos marginales

Los efectos marginales representan el valor esperado de la variable respuesta. Para calcularlos hay que especificar los valores de las variables predictoras (condicionar):

$$E(Y_{ij} | x_{ij1},\ldots,x_{ijK}) = \beta_0 + \sum_{k=i}^K \beta_k x_{ijk}$$

Una vez ajustado el modelo con los datos de la muestra, se estiman los valores de los parámetros para estimar los efectos marginales o predicciones.

$$\hat{E}(Y_{ij} | x_{ij1},\ldots,x_{ijK}) = \hat{\beta}_0 + \sum_{k=i}^K \hat{\beta}_k x_{ijk}$$



### Estimación de los efectos aleatorios

También podemos condicionar al individuo:


$$\hat{E}(Y_{ij} | x_{ij1},\ldots,x_{ijK}, i) = \hat{\beta}_{0i} + \sum_{k=i}^K \hat{\beta}_{ki} x_{ijk}$$

Donde $\hat{\beta}_{0i}$, $\hat{\beta}_{ki}$ son los "Empirical Bayes Estimates".



## Función `lme`

Para ajustar los modelos lineales mixtos usaremos la función **`lme`** del paquete **`nlme`** [@R-nlme].
Esta función permite incorporar efectos aleatorios, así como especificar la estructura de la matriz de correlaciones de los residuos.

El método se basa en el **criterio de máxima verosimilidud** ("Maximum Likelihood" - ML), que busca el valor de los parámetros que maximizan la función de verosimilitud. Generalmente, la solución no es una fórmula cerrada y se necesitan métodos iterativos numéricos para encontrar el óptimo. También se calculan mediante métodos numéricos la primera y segunda derivada para acelerar el proceso de estimación y para obtener los errores estándard de las estimaciones. 

Para usar la función `lme`, los datos deben estar en formato horizontal. No hace falta que haya el mismo número de medidas para cada individuo, ni que las medidas se hayan producido en los mismos tiempos.


```{r}
library(nlme)
```

```{r, eval=FALSE}
?lme
```


Los **argumentos** más importantes de la función `lme`

- **`fixed`**: Fórmula de la forma

``` 
respuesta ~ var1 + var2 + var3

```

La constante se presupone que está y no hace falta escribir `1+`. 
La sintaxis es la misma que para el "formula environment" de otras funciones estándard como `lm` para regresión lineal ordinaria (los términos van separados con `+`, las interacciones se especifican con `:`, etc.). 
A la izquierda de `~` se especifica la variable respuesta.

<br>

- **`random`**: fórmula de la forma

```
 ~ var1 + var2 + ... + varK | indiv
```

sin ninguna variable a la izquierda de `~`, donde `indiv` es la variable sujeto y `var1`, `var2`, ... `varK` son las variables con coeficiente aleatorio. 
Por defecto se supone que la constante está incluida. 


Si se desea que la constante no sea aleatoria
` ~ var1 + ... + varK - 1 | indiv`. 

Si sólo la constante es aleatoria 
` ~ 1 | indiv`

Para especificar que la matriz $\Omega$ es diagonal se usa la función `pdDiag`

`list(indiv = pdDiag( ~ var1 + var2 + ... + varK))`


Si los individuos estuvieran anidados en clústers aleatorios: 
` ~ var1+..| clusters / indiv`

<br>

- **correlation**: Para especificar la forma de la matriz de covarianzas de los residuos $\Sigma_i$. Para más estructuras: `?corClasses`

    - Residuos independientes (valor por defecto): `NULL`
    
    - Simetría compuesta: `corCompSymm()`
    
    - AR(1): `corAR1()`
    
    - ARMA(p,q): `corARMA(p,q)`
    
    - $\phi^{|t_i-t_j|}$: `corCAR1(form = ~ tiempo | indiv)`

    - Sin estructura | `corSymm()`
    
Para `corCAR1`, $\phi$ es la correlación entre dos medidas a distancia de una unidad de tiempo.

**Importante!:** para `corCompSymm`, `corAR1`, `corARMA` o `corSymm`, las medidas tienen que estar ordenadas dentro de cada individuo. Si no, hay que especificar la variable momento, 

```
corAR1(form = ~ tiempo | indiv)
```


<br>

- **weights**: Este argumento modeliza la varianza, $\sigma^2$ según variables. Por defecto, `NULL` que supone que la matriz de covarianzas es la misma para todos los individuos. En lugar de una variable, puede ser el valor predicho, `varFixed(fitted(.))`. Para ver más `?varClasses`.

    - `varPower()`:  $\sigma^2(x) = |x|^{2*\theta}$
    
    - `varFixed()`: $\sigma^2(x) = |x|$
    
    - `varConstPower()` $\sigma^2(x) = (\theta_1 + |x|^{\theta_2})^2$


<br>


- **method**: Método usado para estimar los parámetros (ML o REML). Para usar el LRT, o calcular los índices AIC o BIC se usa el método ML. La función `anova` que compara dos modelos por LRT, reajusta los modelos automàticamente bajo el método ML si han sido estimados con REML.

    - REML ("REstricted Maximum Likelihood"): método por defecto y que proporciona estimaciones no sesgadas de los parámetros.
    
    - ML ("Maximum Likelihood"): proporciona estimaciones de los parámetros sesgados.
    

## Ejemplos

### Ejemplo 1

Analicemos de nuevo el primer ejemplo que vimos en el [anterior tema](#Ejemplo1) y que están disponibles en la base de datos "Ejemplo_1W.csv". Esta fichero contiene los datos de un diseño con 12 individuos en los que se toman los niveles en sangre de un cierto parámetro lipídico. Para cada invidivuo se miden los niveles a 1, 2 y 3 horas. 

Recordemos que los datos se pueden cargar en R mediante

```{r}
datos <- read.csv2("datos/Ejemplo_1W.csv")
```

Ordenamos por individuo y dentro por tiempo dentro de individuo

```{r}
library(dplyr)
datos <- arrange(datos, indiv, tiempo)
```

Primero, ajustamos el modelo más complejo con constante y pendiente aleatoria, y añadimos el tiempo al cuadrado ya que vemos por el gráfico que la tendencia no es lineal.


```{r}
modelo <- lme(fixed = medida ~ poly(tiempo, 2), 
              data=datos,
              random = ~ poly(tiempo, 2) | indiv,
              correlation = corAR1(form = ~ tiempo | indiv)
              )
modelo$modelStruct$corStruct
summary(modelo)
```


- Valor esperado de la constante y coeficientes, $\beta_0, \ldots, \beta_K$. También se conoce como los coeficientes fijos. Para obtener la tabla de sus estimaciones y los p-valores:

```{r}
coef(summary(modelo))
```

- Estimación de los efectos aleatorios, $\color{green}{(\beta_{0i}^{*},\beta_{1i}^{*},\beta_{2i}^{*})}$

```{r}
ranef(modelo)
```

Hay una fila para cada individuo.

La función `ranef` retorna $\hat{\theta}_{ki}$, donde $\beta_{ki} = \beta_k + \theta_{ki}$. Así pues, $\theta_{ki} \sim N\left(0,\sigma_{\beta_{k}}^2\right)$ se pueden interpretar como los **"efectos aleatorios centrados"** tal y como se ha escrito la ecuación del modelo.


- Matriz de covarianzas de la constante y coeficientes aleatorios, $\Omega$:

```{r}
getVarCov(modelo)
```

- Matriz de correlaciones de los residuos, $\Sigma_i$

```{r}
modelo$modelStruct$corStruct
```



Podemos especificar que la correlación entre efectos aleatorios sea cero con la función `pdDiag` en el argumento `random`:

```{r}
modelo2 <- lme(fixed = medida ~ poly(tiempo, 2), 
              data=datos,
              random = list(indiv=pdDiag(~ poly(tiempo, 2))),
              correlation = corAR1()
              )
summary(modelo2)
getVarCov(modelo2)
```


Y para contrastar esta asunción

```{r}
anova(modelo, modelo2)
```
El mejor a escoger es el que contempla que hay correlación entre los efectos aleatorios.



**Simplificación del modelo**

Miramos primero si los coeficientes son aleatorios o fijos. Para ello comparamos el modelo completo con el modelo sólo con la constante aleatoria.

```{r}
anova(modelo, update(modelo, random = ~ 1 | indiv))
```
Con la función `anova` se comparan los dos modelos mediante el LRT, uno con los coeficientes aleatorios y el otro sólo con la constante aleatoria. En este caso, y como se ha dicho, el LRT para constrastar si las varianzas son cero no es del todo adecuado. Existen otros tests basados en remuestreo, pero hasta la fecha no funcionan con `lme` y no se explicarán en este curso.

Basándonos en el LRT, y también el criterio AIC o BIC, se tiene que el modelo más complejo (el que supone que los coeficientes son aleatorios) es el que se eligirá.


Posteriormente miramos si la correlación entre los efectos aleatorios es cero o no:

```{r}
anova(modelo, update(modelo, random=list(indiv=pdDiag(~poly(tiempo,2)))))
```

Nos quedamos con el modelo más complejo, ya que el p-valor del LRT es < 0.005.


Finalmente, miramos si podemos simplificar la matriz de correlación de los residuos. Comparamos mediante el LRT el modelo ajustado con uno que suponga independencia de los residuos: 


```{r}
anova(modelo, update(modelo, correlation=NULL))
```

Como el p-valor > 0.05, elegimos el modelo más simple (el de independencia de los residuos). Además, según el criteria AIC, o BIC (cuánto más bajo mejor), también nos decantamos por el modelo de independencia de los residuos.


```{r}
modelo <- update(modelo, correlation=NULL)
```

En el siguiente paso evaluamos la significación de los efectos fijos:

```{r}
coef(summary(modelo))
```

Todos los coeficientes son significativos. Por lo tanto no podemos simplificar el modelo.


```{r}
summary(modelo)
```


Finalmente, validamos el modelo:

```{r}
par(mfrow=c(1,2))
plot(modelo)
qqnorm(modelo)
```

Según estos gráficos, diremos que sí se cumplen las premisas sobre los residuos.



**Predicciones:**

Para calcular las predicciones nos será útil usar las funciones del paquete **`ggeffects`**. Con este paquete se pueden realizar las predicciones de distinto tipo y también graficarlas con el paquete `ggplot2`.


```{r}
library(ggeffects)
```


```{r}
pr.fixed <- ggpredict(modelo, "tiempo [all]", type="fixed")
pr.fixed
```

```{r}
pr.random <- ggpredict(modelo, "tiempo [all]", type="random")
pr.random
```

Con el argumento `type="random"`, el intervalo es más ancho porque no sólo tiene en cuenta el error estándar de las estimaciones de los parámetros sino también la varianza de los efectos aleatorios.


```{r, eval=FALSE}
library(gridExtra)
grid.arrange(
    plot(pr.fixed) + ylim(25,60) + ggtitle("CI: fixed"),
    plot(pr.random) + ylim(25,60) + ggtitle("CI: random"),
nrow=1, ncol=2)
```


**Resultado**

Por lo tanto el modelo final contendrá el tiempo, el tiempo al cuadrado, la contaste y los coeficientes aleatorios. Finalmente, los residuos se puede suponer independientes. 


**Observaciones**


- Se pueden incorporar **términos splines** en la fórmula usando la función **`ns`** del paquete `spline`. Es útil cuando se tienen muchas medidas repetidas y/o en distintos momentos para los diferentes individuos. Se usa en las fórmulas (argumentos `fixed` i `random`)

```{r, eval=FALSE}
lme(respuesta ~ ns(tiempo), random = ns(tiempo) | indiv, ...)
```



**Comparación con las otras técnicas**

A fin de poder comparar los resultados de los modelo LMM con los modelos basados en la suma de cuadrados y en la respuesta multivariante, el tiempo se debe tratar como factor. Fíjate en el uso de `as.factor` para convertir una variable numérica a factor o variable categórica. Para ello, hay que tener las mismas categorías de tiempo para todos los individuos. Además, tanto los modelos de respuesta multivariable como los basados en suma de cuadrados, asumen la pendiente fija o constante, y la correlación sin estructura.

******

>**Nota:** Es importante notar que las técnicas de respuesta multivariable y de suma de cuadrados al tratar la variable tiempo como factor, no se puede distinguir si tiempos de las medidas son o no equiespaiados. Por ejemplo los resultados obtenidos mediante estas dos técnicas serán los mismos tanto si se recogen las medidas a 1h, 2h y 3h, o si se recoge a 1h, 2h y 6h. En cambio, si se desea estudiar el efecto lineal ambas situaciones son muy distintas.

```{r, echo=FALSE, fig.height=5, fig.width=10}
temp <- read.csv2("datos/Ejemplo_1W.csv")
temp$tiempo2 <- with(temp, ifelse(tiempo==3, 6, tiempo))
library(ggplot2)
p <- ggplot(data = temp, aes(x = tiempo, y = medida, group = indiv))
p <- p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
p1 <- p
p <- ggplot(data = temp, aes(x = tiempo2, y = medida, group = indiv))
p <- p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
p2 <- p
library(gridExtra)
grid.arrange(p1,p2,nrow=1, ncol=2)
```

*****



```{r}
modelo <- lme(fixed = medida ~ as.factor(tiempo), 
              data=datos,
              random = ~ 1 | indiv,
              correlation = corSymm()
              )
summary(modelo)
coef(summary(modelo))
```

La función `anova` aplicada a un sólo modelo ajustado es útil para contrastar la significación de un factor de más de una categoría (o posibles interacciones de factores de más de dos categorías).

```{r}
anova(modelo)
```

### Ejemplo 2

Analicemos ahora los datos introducidos en el capítulo anterior en el [ejercicio 2](#Ejercicio2). Recordemos que en la base de datos "Ejemplo_1W1B.csv" se tienen los datos de un estudio en el que participan 24 individuos randomizados en dos grupos de tratamiento (`trat`). Como en el anterior ejemplo, para cada invidivuo se miden los niveles a 1, 2 y 3 horas.

```{r}
datos <- read.csv2("datos/Ejemplo_1W1B.csv")
```

Como antes, ordenamos por individuo (de 1 a 24) y por tiempo

```{r}
datos <- arrange(datos, indiv2, tiempo)
```

```{r}
modelo <- lme(fixed = medida ~ poly(tiempo,2)*trat, 
              data=datos,
              random = ~ poly(tiempo,2) | indiv2,
              correlation = corAR1()
              )
summary(modelo)
```


**Nota**:
Si los individuos estuvieran anidados dentro de clusters, se especificaría en el argumento `random = ~ 1 | indiv / clusters`, donde "cluster" sería el nombre de la variable que codifica los clusters.


**Observación** Para que el modelo quede bien definido no es posible poner la interacción del tiempo y el tratamiento como coeficiente aleatorio. De esta manera se especifican como aleatorios la costante y los coeficientes del tiempo (lineal y cuadrático) para el grupo control.

Como en el anterior ejemplo, contrastamos la significación de los coeficientes aleatorios del tiempo:


```{r}
anova(modelo, update(modelo, random = ~ 1 | indiv2))
```
Según el criterio AIC o BIC, el modelo con pendientes aleatorias es mejor.


Luego, contrastamos si se puede simplificar la matriz de correlaciones de los efectos aleatorios:

```{r}
anova(modelo, update(modelo, random = list(indiv2=pdDiag(~poly(tiempo,2)))))
```
El test LRT es significativo (p-valor < 0.05). Por lo tanto nos quedamos con el modelo más complejo que supone que hay correlación entre los efectos aleatorios.

Seguidamente, miramos si se puede simplificar la matriz de correlaciones de los errores.

```{r}
anova(modelo, update(modelo, correlation=NULL))
```

Sí que se puede suponer que hay indipendencia entre los residuos.

```{r}
modelo <- update(modelo, correlation=NULL)
```


Por lo tanto el modelo final, que supone independencia entre residuos, tiene la siguiente estimación de los efectos fijos:

```{r}
coef(summary(modelo))
```

Vemos como el efecto del tiempo para el grupo control no llega a ser significativo (p-valores >0.05) tanto para su componente lineal como cuadrático. Hay efecto del tratamiento en el momento basal (`trat2`).

Si queremos ver el efecto del tiempo para el grupo 2, hay que cambiar su categoría de referencia.

```{r}
datos$trat <- relevel(factor(datos$trat),2)
coef(summary(update(modelo)))
```

Vemos que para el grupo 2 tanto la componente lineal como la cuadrática del tiempo son significativas.

Con la siguiente matriz de varianzas y covarianzas de los efectos aleatorios:

```{r}
getVarCov(modelo)
```


Y varianza de los residuos

```{r}
sigma(modelo)^2
```


Por último, validamos el modelo


```{r}
par(mfrow=c(1,2))
plot(modelo)
qqnorm(modelo)
```

Según los gráficos, parece que sí que se cumplen las premisas sobre los residuos.

**Predicciones**

```{r}
pr <- ggpredict(modelo, terms = c("tiempo [all]", "trat"))
pr
plot(pr, add.data = TRUE)
```

### Ejemplo 3

Finalmente, analicemos ahora los datos introducidos en el capítulo anterior en el [ejercicio 3](#Ejercicio3). En un estudio se quieren comparar el efecto de régimen de ejercicio sobre el sobrepeso. Para ello se reclutan 100 personas. A la mitad se le asigna el régimen y al resto se le hacen algunas recomendaciones (grupo control). Se mide el índice de masa corporal justo antes de empezar el estudio (momento basal), y al cabo de 1, 2 y 3 semanas. Como la edad es una variable importante para predecir el IMC también se registra.

Los datos los encontrarás en el fichero "imc.csv"

En este ejemplo, vemos como en algunos de los individuos nos falta alguna medida en a partir de la primera semana. Por este motivo usaremos la técnica de los LMM.

```{r}
datos <- read.csv2("datos/imc.csv")
```


Nos aseguramos que los datos estén ordenados por individuo y tiempo

```{r}
datos <- arrange(datos, indiv, tiempo)
```

Recodificamos nuestra variable tratamiento: 

```{r}
datos$tx <- factor(datos$tx, 1:2, c("Control", "Tratados"))
summary(datos)
```

Recordemos también que estos datos no puedieron ser analizados con métodos tradicionales ya que tienen inviduos con datos faltantes

```{r}
sum(with(datos, tapply(is.na(respuesta), indiv, any)))
```

Elimino las observaciones con valores missing (que no los individuos!)

```{r}
datos <- subset(datos, !is.na(respuesta))
# número de individuos con 2, 3 o 4 medidas válidas.
table(table(datos$indiv))
```

Como siempre, hagamos una visualización de los datos

```{r}
library(ggplot2)
p <- ggplot(data = datos, aes(x = tiempo, y = respuesta, group = indiv))
p <- p + geom_line(col="grey") + stat_summary(aes(group = 1),
    geom = "line", fun = mean, size=2)
p + facet_grid( ~ tx)
```


#### Análisis del grupo control

Si analizamos sólo el grupo control, se trata de un diseño 1W con una covariable (edad).


```{r}
datos <- subset(datos, tx=='Control')
datos <- na.omit(datos)
```

Ajustamos el modelo más completo, con la edad y el tiempo hasta el término cúbico ya que tenemos cuatro medidas.

```{r}
library(nlme)
modelo <- lme(respuesta ~ poly(tiempo,3) + edad, 
              random= ~ poly(tiempo,3) | indiv, 
              data=datos, 
              #correlation = corSymm(), # sin estructura
              correlation=corCAR1(form = ~ tiempo | indiv),
              control=lmeControl(opt="optim"))
summary(modelo)
```

El modelo de correlación sin estructura no converge (NOTA: intentad ejecutar el mismo código cambiando la correlación que tiene por la que está comentada). Es normal ya que tenemos distintas medidas. 

Es importante especificar la AR(1) continua `corCAR1` ya que tenemos algunos individuos con datos faltantes en algunas de sus medidas. Luego el tiempo que ha pasado entre las medidas disponibles hay que tenerlo en cuenta.

Fíjate en la varianza de los efectos aleatorios, sobretodo en la constante si en el modelo no ponemos la edad,


```{r}
modelo0 <- update(modelo, fixed = . ~ . -edad)
getVarCov(modelo)
getVarCov(modelo0) # sin la edad
```


Es importante poner la edad ya que si no, la varianza de los efectos aleatorios quedan infladas y la inferencia no es válida.


**Contraste de los efectos aleatorios**


```{r}
anova(modelo, update(modelo, random= ~ 1 | indiv))
```

Nos quedamos con el modelo con los coeficientes del tiempo fijos:

```{r}
modelo <- update(modelo, random= ~ 1 | indiv)
```

>**Observación** Fíjate en el valor de $\phi$ de la matriz de correlaciones de los errores: al considerar el coeficiente del tiempo como fijo, ha pasado de ser cero a un valor alto. Al considerar el coeficiente aleatorio en cierta manera se inducía una estructura de AR entre las observaciones y ya no hacía falta considerar los errores correlacionados. Por esto, el orden en que se simplifica el modelo es importante.


Si queremos **contrastar si la constante es aletoria** se compara el modelo con todos los efectos fijos. Así que ya no se podrá usar la función `lme` sino que se usará la función `gls` en su lugar.

```{r}
modelo.gls <- gls(respuesta ~ poly(tiempo,3) + edad, 
                  data=datos, 
                  correlation=corCAR1(form = ~ tiempo |indiv))
summary(modelo.gls)
summary(modelo)
```

```{r}
anova(modelo, modelo.gls)
```
Los dos modelos no están anidados. Así que a parte del p-valor del LRT también miraremos el AIC y el BIC. Bajo los tres criterios nos decantamos por el modelo con la constante aleatoria.


**Estructura de correlación de los errores**

Comparamos con la matriz de independencia

```{r}
anova(modelo, update(modelo, correlation=NULL))
```


Nos quedamos con la estructura AR1

**Contraste de los efectos fijos**

```{r}
coef(summary(modelo))
```

Vemos como la parte cuadrática no es significativa y la cúbico tampoco. 
Para contrastar los dos términos (cuadrático y cúbico) a la vez comparamos mediante el LRT el modelo completo con el modelo que supone el efecto del tiempo lineal

```{r}
anova(
  update(modelo, method="ML"), 
  update(modelo, fixed = . ~ . - poly(tiempo,3) + tiempo, method="ML")
)
```

El p-valor > 0.05, por lo tanto nos quedamos con el modelo lineal.

```{r}
modelo <- update(modelo, fixed = . ~ . - poly(tiempo,3) + tiempo)
summary(modelo)
coef(summary(modelo))
```

**Validación del modelo**

- Errores

```{r}
par(mfrow=c(1,2))
plot(modelo)
qqnorm(modelo)
```


- Efectos aleatorios

```{r}
beta0i<- ranef(modelo)[,1]
qqnorm(beta0i); qqline(beta0i)
edad <- with(datos, tapply(edad, indiv, mean))
# gráfico de los efectos aleatorios vs variables individuo
plot(edad, beta0i)
```




Parece que los efectos aleatorios siguen una distribución normal. Y no están relacionados con la edad.


**Predicciones**

```{r}
library(ggeffects)
pr <- ggpredict(modelo, terms = c("tiempo [all]"))
pr
plot(pr, add.data = TRUE)
plot(pr, residuals = TRUE)
```


Las predicciones las realiza en la media de las covariables, en este caso la edad.
Si queremos que las predicciones las haga para un individuo de 55 años:

```{r}
pr <- ggpredict(modelo, terms = c("tiempo [all]"), condition=c("edad"=55))
pr
plot(pr)
```

#### Comparación de los dos tratamientos

```{r}
datos <- read.csv2("datos/imc.csv")
datos <- datos[order(datos$indiv,datos$tiempo),]
datos <- na.omit(datos) # para eliminar datos con missings (pero no individuos)
```


Volvemos al enunciado original trabajando con todos los datos. Ahora el objetivo es comparar la evolución de los dos tratamientos ajustando por la edad.


```{r}
library(nlme)
modelo <- lme(respuesta ~ poly(tiempo, 3, raw=3) + tx:poly(tiempo, 3, raw=3) + edad,
              random= ~ poly(tiempo, 3, raw=3)  | indiv, 
              data=datos, 
              correlation=corCAR1(form = ~ tiempo|indiv))
summary(modelo)
```

Nota: `poly(tiempo, 3, raw=TRUE)` es lo miso que `tiempo + I(tiempo^2) + I(tiempo^3)`.

Fijate cómo se ha escrito la fórmula. De esta manera, cuando tiempo=0 (momento basal) no hay diferencias entre en los tratamientos. 


**Efectos aleatorios**

```{r}
anova(modelo, update(modelo, random = ~ 1 | indiv))
```

Vemos en este caso, como el p-valor del LRT no coincide con la decisión basada en el AIC o el BIC. Podemos decantarnos con el modelo más simple, o sea, el que supone que los coeficientes del tiempo son fijos.


```{r}
modelo <- update(modelo, random = ~ 1 | indiv)
```



**Estructura de correlación de los errores**

Comparamos con la matriz de independencia

```{r}
anova(modelo, update(modelo, correlation=NULL))
```

Nos quedamos con la estructura AR1.

Finalmente, comprovamos los efectos fijos:

```{r}
coef(summary(modelo))
```


Como era de esperar, la edad es muy significativa.

Contrastamos el efecto cuadrático y cúbico del tiempo (tanto para el grupo control como para el grupo de tratados):

```{r}
modelo2 <- update(modelo, fixed = . ~ tiempo + tiempo:tx + edad)
coef(summary(modelo2))
anova(modelo, modelo2)
```

Como el p-valor del LRT es >0.05, nos quedamos con el modelo más simple, en que el tiempo tiene un efecto lineal en ambos grupos

```{r}
modelo <- modelo2
coef(summary(modelo))
```


El efecto del tiempo en el grupo control no es significativo.

Para ver el efecto del tiempo en el grupo de tratamiento, cambiamos la categoria de referencia:


```{r}
datos$tx <- factor(datos$tx, 2:1)
coef(summary(update(modelo)))
```

Vemos como el efecto del tiempo en el grupo de tratados es significativo y la pendiente es negativa.


**Validación**

```{r}
# residuos
plot(modelo)
qqnorm(modelo)

# efectos aleatorios
beta0i <- ranef(modelo)[,1]
grupo <- with(datos, tapply(tx, indiv, head, n=1))
edad <- with(datos, tapply(edad, indiv, mean))
boxplot(beta0i ~ grupo)
plot(edad, beta0i)
```



**Predicciones**

```{r}
datos$tx <- factor(datos$tx, 1:2)
modelo <- update(modelo)

pr.cont <- ggpredict(modelo, terms = c("tiempo"), condition=c(tx=1), type="fixed")
pr.tx <- ggpredict(modelo, terms = c("tiempo"), condition=c(tx=2), type="fixed")
pr.cont
pr.tx

library(gridExtra)
grid.arrange(
    plot(pr.cont) + ylim(24,40) + ggtitle("controles"),
    plot(pr.tx) + ylim(24,40) + ggtitle("tratados"),
nrow=1, ncol=2)
```


## Ejercicios 


### Ejercicio 4

>
Los datos `sleepstudy` de la librería `lme4` contienen información sobre 18 dindividuos que se han seguido durante 9 días, y para los cuales se ha registrado el tiempo de reacción (en milisegundos) tras haber estado en deprivación de sueño. 
>
Los datos pueden cargarse mediante
>
```{r, eval=FALSE}
library(lme4)
data(sleepstudy)
``` 
>
1. Crea un spaguetti plot para ver la evolución de la reacción a lo largo del tiempo
2. Modeliza el tiempo de reacción (variable respuesta) a lo largo de los días. Usa tanto polinomios como splines con la función `ns()`. Puedes usar la función `anova()` con el test LRT para contrastar si es necesario usar términos splines (`ns()`) o polinomios `poly()`).
>

### Ejercicio 5
>
Los datos `dietox` de la librería `geepack` contienen el peso de cerdos medidos semanalmente durante 12 semanas cuando son sacrificados (Weight). Los datos también contienen el peso en la semana 1 (Start), tres niveles diferentes de vitamina E (Evit - dosis: 0, 100, 200 mg dl-alfa-tocoferil acetato / kg de alimento) en combinación con 3 niveles diferentes de cobre (Cu - dosis: 0, 35, 175 mg / kg de alimento) que reciben en el alimento. También se registra la ingesta acumulada de alimento (Feed). Los cerdos son compañeros de camada (Litter). El objetivo principal es ver qué combinación de suplementos en el alimento hace que los cerdos alcancen un mayor peso. 
>
1. Haz una descriptiva de las variables (summary)
2. ¿Qué variables son tiempo dependientes y cuáles no? (crea un gráfico para Weight, Evit y Cu)
3. Ajusta un modelo mixto para contestar a la pregunta científica
4. ¿Qué variables as considerado con efecto aleatorio?
5. ¿Qué estructura de correlaciones has considerado?
6. Intenta cambiar algunos aspectos del modelo (añadir quitar coeficientes aleatorios, estructura de correlación de los errores, simplificar o añadir variables/interacciones, ...) para elegir el mejor modelo
7. Una vez escogido el modelo final, haz un gráfico de la evolución de la variable respuesta a diferentes niveles de `Start`.
